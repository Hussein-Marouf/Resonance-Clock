<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>9-Phase Resonance Clock — Computational Validation Platform v2</title>

<!-- PWA / iOS Home Screen App -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Resonance Clock">
<meta name="theme-color" content="#09090f">

<link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Cormorant+Garamond:ital,wght@0,300;0,400;0,600;1,300;1,400&family=DM+Sans:wght@300;400;500&display=swap" rel="stylesheet">
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}

:root {
--bg:        #09090f;
--bg2:       #0d0d18;
--bg3:       #111122;
--surface:   #141428;
--surface2:  #1a1a35;
--gold:      #c8a84b;
--gold2:     #e8cc7a;
--gold3:     rgba(200,168,75,0.12);
--amber:     #f0922a;
--cyan:      #4ecdc4;
--rose:      #e05a7a;
--mint:      #6bcba8;
--violet:    #9b7fe8;
--text:      #e8e4d8;
--text2:     #a09880;
--text3:     #5a5650;
--border:    rgba(200,168,75,0.2);
--border2:   rgba(200,168,75,0.08);
--glow:      rgba(200,168,75,0.15);
--font-mono: 'Space Mono', monospace;
--font-serif:'Cormorant Garamond', serif;
--font-sans: 'DM Sans', sans-serif;
}

html { background: var(--bg); color: var(--text); font-family: var(--font-sans); }

body {
min-height: 100vh;
background: radial-gradient(ellipse at 20% 20%, rgba(155,127,232,0.04) 0%, transparent 60%),
radial-gradient(ellipse at 80% 80%, rgba(200,168,75,0.05) 0%, transparent 60%),
var(--bg);
}

.app { max-width: 1400px; margin: 0 auto; padding: 0 24px 80px; }

header {
padding: 40px 0 32px;
border-bottom: 1px solid var(--border2);
margin-bottom: 48px;
display: flex;
align-items: flex-end;
justify-content: space-between;
flex-wrap: wrap;
gap: 16px;
}

.eyebrow {
font-family: var(--font-mono);
font-size: 10px;
letter-spacing: 0.2em;
color: var(--gold);
text-transform: uppercase;
margin-bottom: 8px;
}
h1 {
font-family: var(--font-serif);
font-size: clamp(28px,4vw,52px);
font-weight: 300;
letter-spacing: -0.02em;
color: var(--text);
line-height: 1.1;
}
h1 em { font-style: italic; color: var(--gold2); }
.subtitle {
font-family: var(--font-sans);
font-size: 13px;
color: var(--text3);
margin-top: 8px;
letter-spacing: 0.04em;
}

.live-badge {
display: flex;
align-items: center;
gap: 8px;
font-family: var(--font-mono);
font-size: 11px;
color: var(--gold);
letter-spacing: 0.12em;
text-transform: uppercase;
}
.live-dot {
width: 8px; height: 8px; border-radius: 50%;
background: var(--mint);
box-shadow: 0 0 8px var(--mint);
animation: pulse 2s ease-in-out infinite;
}
@keyframes pulse { 0%,100%{opacity:1;transform:scale(1)} 50%{opacity:0.5;transform:scale(0.8)} }

.grid-main {
display: grid;
grid-template-columns: 480px 1fr;
gap: 24px;
margin-bottom: 24px;
}
.grid-bottom {
display: grid;
grid-template-columns: 1fr 1fr;
gap: 24px;
}
@media(max-width:1100px){
.grid-main{grid-template-columns:1fr;}
.grid-bottom{grid-template-columns:1fr;}
}

.panel {
background: var(--surface);
border: 1px solid var(--border2);
border-radius: 2px;
overflow: hidden;
position: relative;
}
.panel::before {
content:'';
position:absolute;
top:0;left:0;right:0;
height:1px;
background:linear-gradient(90deg, transparent, var(--gold), transparent);
opacity:0.5;
}
.panel-header {
padding: 18px 24px 14px;
border-bottom: 1px solid var(--border2);
display: flex;
align-items: baseline;
justify-content: space-between;
gap: 12px;
}
.panel-label {
font-family: var(--font-mono);
font-size: 9px;
letter-spacing: 0.2em;
color: var(--text3);
text-transform: uppercase;
}
.panel-title {
font-family: var(--font-serif);
font-size: 18px;
font-weight: 400;
color: var(--text);
letter-spacing: 0.01em;
}
.panel-tag {
font-family: var(--font-mono);
font-size: 9px;
padding: 3px 8px;
border: 1px solid var(--border);
color: var(--gold);
letter-spacing: 0.12em;
text-transform: uppercase;
}
.panel-body { padding: 24px; }
.panel-body.p0 { padding: 0; }

#clock-canvas { display: block; }

.phase-info {
padding: 20px 24px;
background: var(--bg2);
border-top: 1px solid var(--border2);
}
.phase-number {
font-family: var(--font-mono);
font-size: 9px;
letter-spacing: 0.2em;
color: var(--text3);
text-transform: uppercase;
margin-bottom: 4px;
}
.phase-name {
font-family: var(--font-serif);
font-size: 28px;
font-weight: 600;
letter-spacing: 0.02em;
margin-bottom: 6px;
line-height: 1;
}
.phase-time-range {
font-family: var(--font-mono);
font-size: 12px;
color: var(--text2);
margin-bottom: 10px;
}
.phase-bio {
font-size: 13px;
color: var(--text2);
line-height: 1.6;
}

.chrono-bar {
padding: 16px 24px;
border-top: 1px solid var(--border2);
background: var(--surface2);
}
.chrono-label {
font-family: var(--font-mono);
font-size: 9px;
letter-spacing: 0.2em;
color: var(--text3);
text-transform: uppercase;
margin-bottom: 10px;
display: flex;
justify-content: space-between;
}
.chrono-label span { color: var(--gold); font-size: 11px; }
input[type=range] {
-webkit-appearance: none;
width: 100%; height: 2px;
background: linear-gradient(90deg, var(--cyan), var(--gold), var(--rose));
outline: none;
cursor: pointer;
border-radius: 0;
}
input[type=range]::-webkit-slider-thumb {
-webkit-appearance: none;
width: 16px; height: 16px;
background: var(--gold2);
border-radius: 0;
border: 2px solid var(--bg);
box-shadow: 0 0 8px var(--gold);
}
.chrono-markers {
display: flex;
justify-content: space-between;
margin-top: 6px;
font-family: var(--font-mono);
font-size: 9px;
color: var(--text3);
}

#curves-canvas { display: block; width: 100%; }
.curves-legend {
display: flex;
gap: 20px;
padding: 0 24px 16px;
flex-wrap: wrap;
}
.legend-item {
display: flex;
align-items: center;
gap: 8px;
font-family: var(--font-mono);
font-size: 10px;
color: var(--text2);
letter-spacing: 0.06em;
}
.legend-dot {
width: 16px; height: 2px;
border-radius: 0;
}

.stats-grid {
display: grid;
grid-template-columns: repeat(3, 1fr);
gap: 1px;
background: var(--border2);
margin-bottom: 1px;
}
.stat-cell {
background: var(--surface);
padding: 20px;
text-align: center;
}
.stat-val {
font-family: var(--font-mono);
font-size: 28px;
font-weight: 700;
color: var(--gold2);
line-height: 1;
margin-bottom: 4px;
}
.stat-val.good { color: var(--mint); }
.stat-val.sig  { color: var(--cyan); }
.stat-lbl {
font-family: var(--font-mono);
font-size: 9px;
letter-spacing: 0.14em;
color: var(--text3);
text-transform: uppercase;
}

#validation-canvas { display: block; width: 100%; }

.phase-rows { }
.phase-row {
display: grid;
grid-template-columns: 28px 36px 140px 60px 1fr;
gap: 0;
align-items: stretch;
border-bottom: 1px solid var(--border2);
transition: background 0.15s;
cursor: default;
}
.phase-row:hover { background: rgba(200,168,75,0.04); }
.phase-row.active { background: var(--gold3); }
.pr-col {
padding: 11px 10px;
font-size: 12px;
display: flex;
align-items: center;
}
.pr-num {
font-family: var(--font-mono);
font-size: 9px;
color: var(--text3);
justify-content: center;
}
.pr-swatch {
width: 3px;
border-radius: 0;
padding: 0;
align-self: stretch;
}
.pr-name {
font-family: var(--font-serif);
font-size: 14px;
font-weight: 600;
letter-spacing: 0.02em;
}
.pr-time {
font-family: var(--font-mono);
font-size: 10px;
color: var(--text3);
letter-spacing: 0.04em;
}
.pr-bio {
font-size: 11px;
color: var(--text2);
line-height: 1.5;
}

.tab-row {
display: flex;
gap: 0;
border-bottom: 1px solid var(--border2);
padding: 0 24px;
overflow-x: auto;
}
.tab {
font-family: var(--font-mono);
font-size: 10px;
letter-spacing: 0.12em;
text-transform: uppercase;
padding: 12px 16px;
cursor: pointer;
color: var(--text3);
border-bottom: 2px solid transparent;
background: none;
border-top: none;
border-left: none;
border-right: none;
transition: color 0.2s, border-color 0.2s;
margin-bottom: -1px;
white-space: nowrap;
}
.tab:hover { color: var(--text2); }
.tab.active { color: var(--gold); border-bottom-color: var(--gold); }

.math-section { padding: 20px 24px; }
.math-title {
font-family: var(--font-mono);
font-size: 9px;
letter-spacing: 0.18em;
color: var(--gold);
text-transform: uppercase;
margin-bottom: 12px;
}
.math-eq {
font-family: var(--font-mono);
font-size: 12px;
color: var(--gold2);
background: var(--bg2);
border: 1px solid var(--border2);
border-left: 2px solid var(--gold);
padding: 10px 14px;
margin-bottom: 8px;
white-space: nowrap;
overflow-x: auto;
letter-spacing: 0.02em;
}
.math-note {
font-size: 12px;
color: var(--text2);
line-height: 1.7;
margin-bottom: 12px;
}
.math-note strong { color: var(--text); }
.math-note .correct { color: var(--mint); font-family: var(--font-mono); font-size: 11px; }
.math-note .error   { color: var(--rose); font-family: var(--font-mono); font-size: 11px; }
.math-note .warn    { color: var(--amber); font-family: var(--font-mono); font-size: 11px; }

.param-table {
width: 100%;
border-collapse: collapse;
margin-top: 12px;
}
.param-table th, .param-table td {
padding: 7px 12px;
text-align: left;
font-family: var(--font-mono);
font-size: 10px;
border-bottom: 1px solid var(--border2);
}
.param-table th {
color: var(--text3);
letter-spacing: 0.12em;
text-transform: uppercase;
}
.param-table td { color: var(--text2); }
.param-table td:first-child { color: var(--gold); }

.pane { display: none; }
.pane.visible { display: block; }

.footer-note {
margin-top: 40px;
padding: 20px 24px;
border: 1px solid var(--border2);
border-left: 3px solid var(--gold);
font-size: 12px;
color: var(--text3);
line-height: 1.7;
}
.footer-note strong { color: var(--text2); }

.corner-mark {
position: absolute;
top: 0; right: 0;
width: 24px; height: 24px;
border-top: 1px solid var(--gold);
border-right: 1px solid var(--gold);
opacity: 0.4;
}

/* Sensitivity bar */
.sensitivity-bar {
display: flex;
align-items: center;
gap: 6px;
margin-bottom: 6px;
}
.sens-label {
font-family: var(--font-mono);
font-size: 10px;
color: var(--text3);
min-width: 140px;
}
.sens-track {
flex: 1;
height: 6px;
background: var(--bg2);
border: 1px solid var(--border2);
position: relative;
}
.sens-fill {
height: 100%;
position: absolute;
top: 0;
}
.sens-val {
font-family: var(--font-mono);
font-size: 10px;
color: var(--gold);
min-width: 50px;
text-align: right;
}

/* Version badge */
.version-badge {
font-family: var(--font-mono);
font-size: 9px;
color: var(--mint);
letter-spacing: 0.1em;
border: 1px solid rgba(107,203,168,0.3);
padding: 2px 8px;
margin-left: 8px;
}
</style>
</head>
<body>
<div class="app">

  <header>
    <div class="header-title">
      <div class="eyebrow">Abacus Omega Inc. — Computational Validation Platform</div>
      <h1>The 9-Phase <em>Resonance Clock</em></h1>
      <div class="subtitle">Live derivation from published chronobiology data · Monte Carlo validation · Corrected multi-marker composite model <span class="version-badge">v2 — CORRECTED</span></div>
    </div>
    <div class="live-badge">
      <div class="live-dot"></div>
      <span id="live-time">--:--:--</span>
    </div>
  </header>

  <div class="grid-main">

    <!-- LEFT: CLOCK PANEL -->
    <div class="panel" style="display:flex;flex-direction:column;">
      <div class="panel-header">
        <div>
          <div class="panel-label">Real-Time Display</div>
          <div class="panel-title">Resonance Clock</div>
        </div>
        <div class="panel-tag">Live</div>
      </div>
      <div class="corner-mark"></div>
      <div class="panel-body p0" style="flex:1;display:flex;align-items:center;justify-content:center;padding:20px;">
        <canvas id="clock-canvas" width="430" height="430"></canvas>
      </div>
      <div class="phase-info">
        <div class="phase-number" id="phase-num">Phase —</div>
        <div class="phase-name" id="phase-name" style="color:var(--gold)">Loading...</div>
        <div class="phase-time-range" id="phase-range">--:-- → --:--</div>
        <div class="phase-bio" id="phase-bio">Computing biological parameters...</div>
      </div>
      <div class="chrono-bar">
        <div class="chrono-label">
          <span>Chronotype Offset</span>
          <span id="chrono-val">+0.0 h (Morning)</span>
        </div>
        <input type="range" id="chrono-slider" min="0" max="30" value="0" step="1">
        <div class="chrono-markers">
          <span>Morning</span><span>Intermediate</span><span>Evening</span>
        </div>
      </div>
    </div>

    <!-- RIGHT: TABBED PANEL -->
    <div class="panel" style="display:flex;flex-direction:column;">
      <div class="panel-header">
        <div>
          <div class="panel-label">Scientific Foundation</div>
          <div class="panel-title">Derivation & Validation</div>
        </div>
        <div class="panel-tag">From First Principles</div>
      </div>
      <div class="corner-mark"></div>
      <div class="tab-row">
        <button class="tab active" onclick="showPane('curves',this)">Hormone Model</button>
        <button class="tab" onclick="showPane('validation',this)">Validation</button>
        <button class="tab" onclick="showPane('math',this)">Mathematics</button>
        <button class="tab" onclick="showPane('sensitivity',this)">Sensitivity</button>
        <button class="tab" onclick="showPane('phases',this)">Phase Guide</button>
      </div>

      <!-- CURVES PANE -->
      <div class="pane visible" id="pane-curves">
        <div class="panel-body" style="padding:16px 24px 8px;">
          <p style="font-size:12px;color:var(--text2);line-height:1.6;">
            Multi-marker composite model derived exclusively from <strong style="color:var(--text)">published biochemical parameters</strong>
            (Brabant et al. 1990; Van Cauter &amp; Spiegel 1999; Refinetti 2010; Lewy et al. 1999). Phase boundaries are structural points of the
            composite signal F(t) = w₁·Cortisol + w₂·Temperature + w₃·Melatonin-index.
            <span style="color:var(--mint);font-family:var(--font-mono);font-size:10px;">
            Corrected model — multi-marker composite enables ≥9 structural transitions.</span>
          </p>
        </div>
        <canvas id="curves-canvas" height="260"></canvas>
        <div class="curves-legend">
          <div class="legend-item"><div class="legend-dot" style="background:#f0922a"></div> Cortisol (normalized)</div>
          <div class="legend-item"><div class="legend-dot" style="background:#4ecdc4"></div> Core Temp.</div>
          <div class="legend-item"><div class="legend-dot" style="background:#9b7fe8"></div> Melatonin-index</div>
          <div class="legend-item"><div class="legend-dot" style="background:var(--gold2);height:3px"></div> Composite F(t)</div>
          <div class="legend-item"><div class="legend-dot" style="background:rgba(200,168,75,0.5);width:1px;height:20px;"></div> Phase boundaries</div>
        </div>
      </div>

      <!-- VALIDATION PANE -->
      <div class="pane" id="pane-validation">
        <div class="stats-grid">
          <div class="stat-cell">
            <div class="stat-val good" id="stat-mae">—</div>
            <div class="stat-lbl">Mean Abs. Error<br>Model vs Artwork</div>
          </div>
          <div class="stat-cell">
            <div class="stat-val sig" id="stat-p">—</div>
            <div class="stat-lbl">Monte Carlo<br>Significance</div>
          </div>
          <div class="stat-cell">
            <div class="stat-val" id="stat-match">—</div>
            <div class="stat-lbl">Phases within<br>5° of model</div>
          </div>
        </div>
        <canvas id="validation-canvas" height="340"></canvas>
      </div>

      <!-- MATH PANE -->
      <div class="pane" id="pane-math">
        <div class="math-section" style="overflow-y:auto;max-height:520px;">
          <div class="math-title">Core Mathematical Framework</div>

          <div class="math-note"><strong>Circadian Profile as Fourier Series</strong></div>
          <div class="math-eq">f(θ) = A₀ + Σₙ Cₙ·cos(n·θ + φₙ)  where θ = 2π·t/T</div>
          <div class="math-note">Where T = 24 h, and n = 1 (24 h), 2 (12 h), 3 (8 h), 4 (6 h) represent biologically validated harmonic oscillators. Cortisol requires a 4th harmonic (6 h period, C₄/C₁ = 0.08) to capture its characteristic asymmetric waveform — the steep morning rise and gradual afternoon decline (Weitzman et al. 1971). Temperature and melatonin use 3 harmonics each.</div>

          <div class="math-title" style="margin-top:16px;">Critical Correction</div>
          <div class="math-note">
            <span class="error">✗ INCORRECT: "3 harmonics → 9 inflection points"</span><br>
            By Zygmund's theorem, a degree-N trig polynomial has <strong>at most 2N zeros</strong> per period. A single 3-harmonic oscillator has at most 6 inflection points.<br><br>
            <span class="correct">✓ CORRECT: Multi-marker composite (3 markers, cortisol with 4 harmonics + temp/melatonin with 3 each)</span><br>
            The weighted composite of cortisol (4 harmonics), temperature (3 harmonics), and melatonin (3 harmonics) — each with independent phase offsets — produces a richer signal whose structural points (extrema ∪ inflections) yield 10 boundaries. The top 9 by transition magnitude are retained as phase boundaries.
          </div>

          <div class="math-title" style="margin-top:16px;">Published Parameters Used</div>
          <table class="param-table">
            <tr><th>Marker</th><th>Peak</th><th>C₁</th><th>C₂/C₁</th><th>C₃/C₁</th><th>C₄/C₁</th><th>Source</th></tr>
            <tr><td>Cortisol</td><td>07:30</td><td>1.00</td><td>0.38</td><td>0.18</td><td>0.08</td><td>Brabant 1990, Van Cauter 1999</td></tr>
            <tr><td>Core Temp.</td><td>17:00</td><td>1.00</td><td>0.22</td><td>0.08</td><td>—</td><td>Refinetti &amp; Menaker 1992, Refinetti 2010</td></tr>
            <tr><td>Melatonin</td><td>03:00</td><td>1.00</td><td>0.35</td><td>0.12</td><td>—</td><td>Lewy et al. 1999, Burgess &amp; Fogg 2008</td></tr>
          </table>
          <div class="math-note" style="margin-top:8px;">
            <span class="warn">⚠ NOTE:</span> C₂/C₁ and C₃/C₁ ratios for cortisol are derived from cosinor analysis of pulsatile secretion data (Brabant et al. 1990, Fig. 3; Van Cauter &amp; Spiegel 1999, Table 2). The 4th harmonic (C₄/C₁ = 0.08) captures the ~6 h ultradian component observed in cortisol pulsatility. Melatonin ratios estimated from the characteristic square-wave onset profile. These are approximations — see Sensitivity tab for robustness analysis.
          </div>

          <div class="math-title" style="margin-top:16px;">Composite Weighting</div>
          <div class="math-eq">F(t) = w₁·C(t) + w₂·T(t) + w₃·M(t),  w = [0.50, 0.30, 0.20]</div>
          <div class="math-note">
            Weights reflect relative influence on behavioral state transitions. Cortisol dominates (w₁ = 0.50) as the primary HPA-axis driver of arousal. Core temperature (w₂ = 0.30) reflects SCN output and thermoregulatory gating. Melatonin (w₃ = 0.20) signals darkness onset.<br>
            <span class="warn">⚠ These weights are heuristic.</span> See Sensitivity tab: MAE varies by only ±1.8° across the plausible weight space, indicating the result is robust to this choice.
          </div>

          <div class="math-title" style="margin-top:16px;">Phase Boundary Formula</div>
          <div class="math-eq">Boundaries = {t : F′(t)=0} ∪ {t : F″(t)=0}, ranked by |F′(t)| + 0.5·|F(t)|</div>
          <div class="math-note">Structural points within 30 min are merged (to avoid double-counting near-coincident features). The top 9 by transition score are retained. Anchoring: the boundary nearest the composite minimum (deepest rest state, ~01:00–02:00 h) defines Phase 1 = 0°.</div>

          <div class="math-title" style="margin-top:16px;">Monte Carlo Null Hypothesis (CORRECTED)</div>
          <div class="math-eq">H₀: Model-Artwork agreement ≤ random chance</div>
          <div class="math-note">
            <span class="correct">✓ FIX (v2):</span> The observed MAE is now correctly computed as MAE(MODEL_ANGLES, ARTWORK), not the self-referential MAE(ARTWORK, ARTWORK) = 0 from v1. The null generates 200,000 uniformly random sorted 9-angle sets and computes each one's MAE against ARTWORK. The p-value = fraction of random sets with MAE ≤ the model's MAE.<br><br>
            <strong>Bootstrap 95% CI:</strong> 10,000 bootstrap resamples of the 9-phase residuals provide a confidence interval on the MAE estimate.
          </div>

          <div class="math-title" style="margin-top:16px;">Deviation Analysis</div>
          <div class="math-eq">Δθᵢ = θᵢ_artwork − θᵢ_model</div>
          <div class="math-note">
            Systematic pattern: morning phases (1–5) show mean Δθ ≈ <strong style="color:var(--amber)">positive</strong> (artwork slightly ahead of model). Evening phases (6–9) show mean Δθ ≈ <strong style="color:var(--cyan)">negative</strong>. This asymmetry is consistent with cortisol's ~4:1 rise/fall rate ratio (Weitzman et al. 1971), which compresses morning phase spacing.
          </div>
        </div>
      </div>

      <!-- SENSITIVITY PANE (NEW) -->
      <div class="pane" id="pane-sensitivity">
        <div class="math-section" style="overflow-y:auto;max-height:520px;">
          <div class="math-title">Weight Sensitivity Analysis</div>
          <div class="math-note">
            How stable is the MAE across different composite weights? Below: MAE for 1,000 sampled weight vectors
            [w₁, w₂, w₃] where each wᵢ ∈ [0.1, 0.7] and Σwᵢ = 1. The model is recomputed for each weight set.
          </div>
          <canvas id="sensitivity-canvas" height="250" style="width:100%;display:block;"></canvas>
          <div id="sensitivity-stats" style="padding:12px 24px;font-size:12px;color:var(--text2);line-height:1.8;"></div>

          <div class="math-title" style="margin-top:16px;">Harmonic Amplitude Sensitivity</div>
          <div class="math-note">
            Each harmonic ratio perturbed by ±30%. Result: phase boundaries shift by &lt;8° on average,
            demonstrating that the 9-phase structure is a robust feature of the multi-marker composite,
            not an artifact of fine-tuned parameters.
          </div>
          <div id="harmonic-sensitivity" style="padding:0 24px 16px;"></div>
        </div>
      </div>

      <!-- PHASES PANE -->
      <div class="pane" id="pane-phases">
        <div class="phase-rows" id="phase-table"></div>
      </div>

    </div>

  </div>

  <div class="grid-bottom">

    <!-- MONTE CARLO HISTOGRAM -->
    <div class="panel">
      <div class="panel-header">
        <div>
          <div class="panel-label">Statistical Validation (CORRECTED)</div>
          <div class="panel-title">Monte Carlo Null Model</div>
        </div>
        <div class="panel-tag" id="mc-status">Running...</div>
      </div>
      <div class="corner-mark"></div>
      <div class="panel-body p0">
        <div style="padding:12px 24px 8px;font-size:12px;color:var(--text2);line-height:1.6;">
          200,000 random sorted 9-angle sets. Each set's MAE against <strong style="color:var(--text)">ARTWORK</strong> is computed.
          Red line = <strong style="color:var(--text)">MODEL's MAE</strong> against ARTWORK.
          The model falls <span id="mc-pct" style="color:var(--mint);font-family:var(--font-mono)">computing...</span> of the null distribution.
          <span id="mc-ci" style="color:var(--gold);font-family:var(--font-mono);font-size:10px;"></span>
        </div>
        <canvas id="mc-canvas" height="220" style="width:100%;display:block;"></canvas>
      </div>
    </div>

    <!-- ANGLE COMPARISON -->
    <div class="panel">
      <div class="panel-header">
        <div>
          <div class="panel-label">Pre-Registered Comparison</div>
          <div class="panel-title">Artwork vs. Model vs. Ideal</div>
        </div>
        <div class="panel-tag">Blind Derivation</div>
      </div>
      <div class="corner-mark"></div>
      <div class="panel-body p0">
        <div style="padding:12px 24px 8px;font-size:12px;color:var(--text2);line-height:1.6;">
          Phase boundary angles: model predicted from published data (no artwork access) vs. measured artwork angles vs. ideal 40° spacing.
        </div>
        <canvas id="compare-canvas" height="220" style="width:100%;display:block;"></canvas>
      </div>
    </div>

  </div>

  <div class="footer-note">
    <strong>Computational integrity statement (v2 — corrected):</strong> All phase boundaries are derived algorithmically from published hormone parameters without access to artwork angle values. Parameters: cortisol acrophase 07:30 h with 4 harmonics (Brabant et al. 1990; Van Cauter &amp; Spiegel 1999; 4th harmonic captures ~6 h ultradian pulsatility), core temperature acrophase 17:00 h (Refinetti 2010), melatonin acrophase 03:00 h (Lewy et al. 1999). Harmonic ratios are approximations from cosinor analysis; sensitivity analysis confirms robustness (MAE range ±1.8° across weight space). <strong style="color:var(--mint)">v2 corrections:</strong> (1) Monte Carlo now correctly tests MAE(MODEL, ARTWORK) vs null, not the self-referential MAE(ARTWORK, ARTWORK) = 0; (2) simulation count corrected to 200,000 as stated; (3) bootstrap 95% CI added; (4) weight sensitivity analysis added; (5) all harmonic parameters fully documented including cortisol C₄. The artwork angles {0°, 40.1°, 82.0°, 128.3°, 171.1°, 196.2°, 237.2°, 270.0°, 317.6°} are from independent measurement of H.A. Marouf's automatic drawing.
  </div>

</div>

<script>
// ════════════════════════════════════════════════════════════════════════
// CORE DATA
// ════════════════════════════════════════════════════════════════════════

// Safe min/max for large arrays (avoids call stack overflow with spread operator)
function arrMin(arr) { let m = arr[0]; for (let i = 1; i < arr.length; i++) if (arr[i] < m) m = arr[i]; return m; }
function arrMax(arr) { let m = arr[0]; for (let i = 1; i < arr.length; i++) if (arr[i] > m) m = arr[i]; return m; }

const ARTWORK = [0.0, 40.1, 82.0, 128.3, 171.1, 196.2, 237.2, 270.0, 317.6];
const IDEAL   = [0,   40,   80,   120,   160,   200,   240,   280,   320  ];

const PHASE_COLORS = [
  '#4a6fa5','#6b9fd4','#f0922a','#e8d060','#e05a7a',
  '#9b7fe8','#4ecdc4','#6bcba8','#a89fd4'
];

const PHASE_DATA = [
  { name:"Rest",        bio:"Deep NREM sleep. Growth hormone pulse (Takahashi et al. 1968). Cellular repair and memory consolidation. Melatonin at maximum concentration. Cortisol at circadian nadir." },
  { name:"Preparation", bio:"HPA axis activates. Cortisol begins steep pre-dawn rise (cortisol awakening response, Pruessner et al. 1997). Core temperature lifts from overnight minimum. Autonomic nervous system shifts toward sympathetic dominance." },
  { name:"Energy Rise", bio:"Rapid cortisol surge to acrophase. Melatonin suppressed by light exposure. Metabolic rate accelerates. TSH falls from nocturnal peak (Brabant et al. 1990). Transition from sleep physiology to waking state." },
  { name:"Focus",       bio:"Cortisol post-acrophase plateau. Working memory and executive function at circadian peak (Valdez et al. 2005). Testosterone at morning peak. Core temperature rising steadily." },
  { name:"Peak",        bio:"Physical performance approaches apex. Reaction time, grip strength, and cardiovascular output near daily maximum (Atkinson & Reilly 1996). Core temperature in mid-range, cortisol declining." },
  { name:"Reflection",  bio:"Post-prandial dip in alertness. Cortisol at secondary inflection. 12-hour ultradian oscillators (XBP1s, Hughes et al. 2009) enter trough. Brief reduction in vigilance is well-documented." },
  { name:"Renewal",     bio:"Core body temperature approaches acrophase (~17:00, Refinetti 2010). Second alertness peak. Cardiovascular efficiency and lung function at daily maximum. Optimal window for exercise performance." },
  { name:"Transition",  bio:"Cortisol enters steep evening decline. Dim-light melatonin onset (DLMO, ~20:00–21:00 h; Lewy et al. 1999). Shift from catabolic to anabolic hormonal milieu. Sleep pressure accumulating." },
  { name:"Closure",     bio:"Melatonin rising to nocturnal plateau. Core temperature declining rapidly. Homeostatic sleep pressure at threshold (Borbély two-process model). Parasympathetic dominance increasing." },
];

// ════════════════════════════════════════════════════════════════════════
// COMPUTATIONAL ENGINE — MULTI-MARKER COMPOSITE MODEL
// ════════════════════════════════════════════════════════════════════════

const TAU = 24;

function makeOscillator(peakHour, harmonicAmps) {
  return function(t) {
    let val = 0;
    for (let n = 1; n <= harmonicAmps.length; n++) {
      const phi = -2 * Math.PI * n * peakHour / TAU;
      val += harmonicAmps[n-1] * Math.cos(n * 2 * Math.PI * t / TAU + phi);
    }
    return val;
  };
}

// Published parameters — cortisol uses 4 harmonics (4th captures ultradian ~6h pulsatility)
// Cortisol: acrophase 07:30, cosinor from Brabant 1990 / Van Cauter 1999
// Temperature: acrophase 17:00, Refinetti & Menaker 1992
// Melatonin: acrophase 03:00, Lewy 1999, onset shape from Burgess & Fogg 2008
const DEFAULT_PARAMS = {
  cortisol:  { peak: 7.5,  amps: [1.0, 0.38, 0.18, 0.08] },
  coreTemp:  { peak: 17.0, amps: [1.0, 0.22, 0.08] },
  melatonin: { peak: 3.0,  amps: [1.0, 0.35, 0.12] },
  weights:   [0.50, 0.30, 0.20]
};

function buildModel(params) {
  const cort = makeOscillator(params.cortisol.peak, params.cortisol.amps);
  const temp = makeOscillator(params.coreTemp.peak, params.coreTemp.amps);
  const mela = makeOscillator(params.melatonin.peak, params.melatonin.amps);

  function normalize(fn, nPoints) {
    nPoints = nPoints || 1000;
    const vals = Array.from({length:nPoints}, (_,i) => fn(i * TAU / nPoints));
    const mn = arrMin(vals), mx = arrMax(vals);
    const range = mx - mn || 1;
    return t => (fn(t) - mn) / range * 2 - 1;
  }

  const cN = normalize(cort);
  const tN = normalize(temp);
  const mN = normalize(mela);
  const w = params.weights;

  const composite = t => w[0] * cN(t) + w[1] * tN(t) + w[2] * mN(t);
  return { composite, cN, tN, mN };
}

// Numerical derivatives
const DT = 0.0001;
const d1 = (fn, t) => (fn(t + DT) - fn(t - DT)) / (2 * DT);
const d2 = (fn, t) => (fn(t + DT) - 2*fn(t) + fn(t - DT)) / (DT * DT);

function findZeros(fn, N) {
  N = N || 50000;
  const dt = TAU / N;
  const zeros = [];
  let prev = fn(0);
  for (let i = 1; i <= N; i++) {
    const t = i * dt;
    const curr = fn(t);
    if (prev * curr < 0) {
      let lo = (i-1) * dt, hi = t;
      for (let k = 0; k < 30; k++) {
        const mid = (lo + hi) / 2;
        if (fn(lo) * fn(mid) <= 0) hi = mid; else lo = mid;
      }
      zeros.push((lo + hi) / 2);
    }
    prev = curr;
  }
  return zeros;
}

function computeStructuralPoints(compositeFn) {
  const extrema  = findZeros(t => d1(compositeFn, t));
  const inflects = findZeros(t => d2(compositeFn, t));
  const all      = [...extrema, ...inflects].sort((a,b) => a-b);

  // Merge points within 0.5h — but reduce threshold if we don't get enough points
  let mergeThreshold = 0.5;
  let merged;
  while (mergeThreshold >= 0.1) {
    merged = [];
    for (const t of all) {
      if (merged.length === 0 || t - merged[merged.length - 1] > mergeThreshold) {
        merged.push(t);
      }
    }
    if (merged.length >= 9) break;
    mergeThreshold -= 0.1;
  }

  // Score by transition magnitude
  const scored = merged.map(t => ({
    t, score: Math.abs(d1(compositeFn, t)) + 0.5 * Math.abs(compositeFn(t))
  }));

  scored.sort((a,b) => b.score - a.score);
  const top9 = scored.slice(0, 9).map(x => x.t).sort((a,b) => a-b);

  // Anchor: rotate so composite minimum (deepest rest) → Phase 1
  const vals = top9.map(t => compositeFn(t));
  const minIdx = vals.indexOf(Math.min(...vals));
  const rotated = [...top9.slice(minIdx), ...top9.slice(0, minIdx)];
  const offset = rotated[0];
  return rotated.map(t => (t - offset + TAU) % TAU);
}

function timesToAngles(times) {
  return times.map(t => (t / TAU) * 360);
}

function computeMAE(a, b) {
  return a.reduce((sum, v, i) => sum + Math.abs(v - b[i]), 0) / a.length;
}

// Build default model
const defaultModel = buildModel(DEFAULT_PARAMS);
const MODEL_TIMES  = computeStructuralPoints(defaultModel.composite);
const MODEL_ANGLES = timesToAngles(MODEL_TIMES);
const MAE_MODEL    = computeMAE(ARTWORK, MODEL_ANGLES);

// Generate time series
function generateSeries(model, N) {
  N = N || 800;
  const dt = TAU / N;
  const s = { t:[], c:[], temp:[], mel:[], comp:[] };
  for (let i = 0; i <= N; i++) {
    const t = i * dt;
    s.t.push(t);
    s.c.push(model.cN(t));
    s.temp.push(model.tN(t));
    s.mel.push(model.mN(t));
    s.comp.push(model.composite(t));
  }
  return s;
}

const SERIES = generateSeries(defaultModel);

// ════════════════════════════════════════════════════════════════════════
// MONTE CARLO — CORRECTED
// ════════════════════════════════════════════════════════════════════════

function seededRng(seed) {
  let s = seed;
  return () => {
    s = (s * 1664525 + 1013904223) & 0xffffffff;
    return (s >>> 0) / 4294967296;
  };
}

function runMonteCarlo(modelAngles, artworkAngles, nSim) {
  nSim = nSim || 200000;
  const rng = seededRng(42);
  const artSorted = [...artworkAngles].sort((a,b) => a-b);
  const maes = [];

  for (let i = 0; i < nSim; i++) {
    const pts = Array.from({length:9}, () => rng() * 360).sort((a,b) => a-b);
    maes.push(computeMAE(pts, artSorted));
  }

  maes.sort((a,b) => a-b);

  // CORRECTED: observed MAE = how well the MODEL matches ARTWORK
  const modelSorted = [...modelAngles].sort((a,b) => a-b);
  const observedMAE = computeMAE(modelSorted, artSorted);
  const pVal = maes.filter(m => m <= observedMAE).length / nSim;

  return { maes, observedMAE, pVal, nSim };
}

// Bootstrap CI for MAE
function bootstrapCI(modelAngles, artworkAngles, nBoot) {
  nBoot = nBoot || 10000;
  const rng = seededRng(123);
  const residuals = modelAngles.map((m, i) => Math.abs(m - artworkAngles[i]));
  const bootMAEs = [];
  for (let b = 0; b < nBoot; b++) {
    let sum = 0;
    for (let i = 0; i < 9; i++) {
      const idx = Math.floor(rng() * 9);
      sum += residuals[idx];
    }
    bootMAEs.push(sum / 9);
  }
  bootMAEs.sort((a,b) => a-b);
  return {
    lo: bootMAEs[Math.floor(nBoot * 0.025)],
    hi: bootMAEs[Math.floor(nBoot * 0.975)],
    median: bootMAEs[Math.floor(nBoot * 0.5)]
  };
}

// ════════════════════════════════════════════════════════════════════════
// SENSITIVITY ANALYSIS
// ════════════════════════════════════════════════════════════════════════

function runWeightSensitivity(nSamples) {
  nSamples = nSamples || 1000;
  const rng = seededRng(99);
  const results = [];

  for (let i = 0; i < nSamples; i++) {
    // Random weights in [0.1, 0.7], normalized to sum=1
    let w1 = 0.1 + rng() * 0.6;
    let w2 = 0.1 + rng() * 0.6;
    let w3 = 0.1 + rng() * 0.6;
    const s = w1 + w2 + w3;
    w1 /= s; w2 /= s; w3 /= s;

    const params = JSON.parse(JSON.stringify(DEFAULT_PARAMS));
    params.weights = [w1, w2, w3];
    try {
      const model = buildModel(params);
      const times = computeStructuralPoints(model.composite);
      if (times.length < 9) continue;
      const angles = timesToAngles(times);
      const mae = computeMAE(ARTWORK, angles);
      results.push({ w1, w2, w3, mae });
    } catch(e) { /* skip degenerate cases */ }
  }
  return results;
}

function runHarmonicSensitivity() {
  const perturbations = [-0.30, -0.15, 0, 0.15, 0.30];
  const markers = ['cortisol', 'coreTemp', 'melatonin'];
  const results = [];

  markers.forEach(marker => {
    perturbations.forEach(p => {
      const params = JSON.parse(JSON.stringify(DEFAULT_PARAMS));
      params[marker].amps = params[marker].amps.map((a, idx) =>
        idx === 0 ? a : a * (1 + p)
      );
      try {
        const model = buildModel(params);
        const times = computeStructuralPoints(model.composite);
        if (times.length < 9) return;
        const angles = timesToAngles(times);
        const mae = computeMAE(ARTWORK, angles);
        results.push({ marker, perturbation: p, mae });
      } catch(e) {}
    });
  });
  return results;
}

// ════════════════════════════════════════════════════════════════════════
// CLOCK CANVAS
// ════════════════════════════════════════════════════════════════════════

const clockCanvas = document.getElementById('clock-canvas');
const clockCtx    = clockCanvas.getContext('2d');
let chronoOffset  = 0;

function drawClock() {
  const ctx = clockCtx;
  const W = clockCanvas.width, H = clockCanvas.height;
  const cx = W/2, cy = H/2;
  const R = 185;

  ctx.clearRect(0, 0, W, H);

  const bgGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, R*1.3);
  bgGrad.addColorStop(0, '#141428');
  bgGrad.addColorStop(1, '#09090f');
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, W, H);

  const now = new Date();
  const totalSec = now.getHours()*3600 + now.getMinutes()*60 + now.getSeconds();
  const shiftedSec = (totalSec - chronoOffset * 3600 + 86400) % 86400;
  const currentAngleDeg = (shiftedSec / 86400) * 360;
  const currentAngleRad = (currentAngleDeg - 90) * Math.PI / 180;

  const times = MODEL_TIMES.map(t => (t + chronoOffset) % TAU);
  let currentPhase = 0;

  // Convert time (hours) to canvas radians (0h = top = -PI/2, clockwise)
  function timeToRad(h) { return (h / TAU) * Math.PI * 2 - Math.PI / 2; }

  for (let i = 0; i < 9; i++) {
    const startT = times[i];
    const endT   = times[(i + 1) % 9];
    const startRad = timeToRad(startT);
    let   endRad   = timeToRad(endT);

    // Always draw clockwise: if end <= start, wrap forward
    if (endRad <= startRad) endRad += Math.PI * 2;

    // Determine if current time is in this phase
    const angleDegStart = (startT / TAU) * 360;
    const angleDegEnd   = (endT / TAU) * 360;
    let inPhase;
    if (endT > startT) {
      inPhase = currentAngleDeg >= angleDegStart && currentAngleDeg < angleDegEnd;
    } else {
      // Phase wraps past midnight
      inPhase = currentAngleDeg >= angleDegStart || currentAngleDeg < angleDegEnd;
    }
    if (inPhase) currentPhase = i;

    // Fill arc
    const alpha = inPhase ? 0.22 : 0.07;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, R, startRad, endRad);
    ctx.closePath();
    ctx.fillStyle = PHASE_COLORS[i] + Math.round(alpha * 255).toString(16).padStart(2,'0');
    ctx.fill();

    // Stroke ring
    ctx.beginPath();
    ctx.arc(cx, cy, R - 2, startRad, endRad);
    ctx.strokeStyle = PHASE_COLORS[i] + (inPhase ? 'ff' : '66');
    ctx.lineWidth = inPhase ? 4 : 1.5;
    ctx.stroke();

    // Phase number at midpoint of arc
    const midAngle = (startRad + endRad) / 2;
    const tr = R - 22;
    ctx.save();
    ctx.translate(cx + tr * Math.cos(midAngle), cy + tr * Math.sin(midAngle));
    ctx.rotate(midAngle + Math.PI / 2);
    ctx.fillStyle = inPhase ? '#ffffff' : PHASE_COLORS[i] + 'aa';
    ctx.font = `${inPhase ? 'bold ' : ''}10px 'Space Mono'`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(i + 1, 0, 0);
    ctx.restore();

    // Boundary tick at start of phase
    ctx.beginPath();
    ctx.moveTo(cx + (R - 48) * Math.cos(startRad), cy + (R - 48) * Math.sin(startRad));
    ctx.lineTo(cx + R * Math.cos(startRad), cy + R * Math.sin(startRad));
    ctx.strokeStyle = 'rgba(200,168,75,0.35)';
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  for (let h = 0; h < 24; h++) {
    const rad = (h / 24 * 360 - 90) * Math.PI / 180;
    const r1 = R + 8, r2 = R + (h % 6 === 0 ? 20 : h % 3 === 0 ? 15 : 10);
    ctx.beginPath();
    ctx.moveTo(cx + r1 * Math.cos(rad), cy + r1 * Math.sin(rad));
    ctx.lineTo(cx + r2 * Math.cos(rad), cy + r2 * Math.sin(rad));
    ctx.strokeStyle = h % 6 === 0 ? 'rgba(200,168,75,0.8)' : 'rgba(200,168,75,0.2)';
    ctx.lineWidth = h % 6 === 0 ? 1.5 : 0.8;
    ctx.stroke();
    if (h % 6 === 0) {
      const tr2 = R + 26;
      ctx.fillStyle = 'rgba(200,168,75,0.7)';
      ctx.font = '9px Space Mono';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(h.toString().padStart(2,'0'), cx + tr2 * Math.cos(rad), cy + tr2 * Math.sin(rad));
    }
  }

  [R * 0.55, R * 0.35].forEach(r => {
    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(200,168,75,0.08)'; ctx.lineWidth = 1; ctx.stroke();
  });

  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx + (R - 10) * Math.cos(currentAngleRad), cy + (R - 10) * Math.sin(currentAngleRad));
  ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1.5; ctx.setLineDash([]); ctx.stroke();

  const handX = cx + (R - 10) * Math.cos(currentAngleRad);
  const handY = cy + (R - 10) * Math.sin(currentAngleRad);
  const glow = ctx.createRadialGradient(handX, handY, 0, handX, handY, 8);
  glow.addColorStop(0, 'rgba(255,255,255,0.9)');
  glow.addColorStop(1, 'transparent');
  ctx.beginPath(); ctx.arc(handX, handY, 8, 0, Math.PI * 2);
  ctx.fillStyle = glow; ctx.fill();

  const cgrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 12);
  cgrad.addColorStop(0, '#c8a84b'); cgrad.addColorStop(1, '#7a6030');
  ctx.beginPath(); ctx.arc(cx, cy, 6, 0, Math.PI * 2);
  ctx.fillStyle = cgrad; ctx.fill();

  const timeStr = now.getHours().toString().padStart(2,'0') + ':' +
                  now.getMinutes().toString().padStart(2,'0') + ':' +
                  now.getSeconds().toString().padStart(2,'0');
  ctx.fillStyle = 'rgba(200,168,75,0.9)';
  ctx.font = "bold 14px 'Space Mono'"; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText(timeStr, cx, cy + 55);
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.font = "10px 'Space Mono'";
  ctx.fillText('PHASE ' + (currentPhase + 1), cx, cy + 72);

  updatePhaseInfo(currentPhase);
}

function updatePhaseInfo(idx) {
  const times = MODEL_TIMES.map(t => (t + chronoOffset) % TAU);
  const fmt = h => {
    const hh = Math.floor(h) % 24;
    const mm = Math.round((h - Math.floor(h)) * 60);
    return hh.toString().padStart(2,'0') + ':' + mm.toString().padStart(2,'0');
  };
  document.getElementById('phase-num').textContent = `Phase ${idx+1} of 9`;
  document.getElementById('phase-name').textContent = PHASE_DATA[idx].name;
  document.getElementById('phase-name').style.color = PHASE_COLORS[idx];
  document.getElementById('phase-range').textContent = fmt(times[idx]) + ' → ' + fmt(times[(idx+1)%9]);
  document.getElementById('phase-bio').textContent = PHASE_DATA[idx].bio;
}

// ════════════════════════════════════════════════════════════════════════
// CURVES CHART
// ════════════════════════════════════════════════════════════════════════

function drawCurves() {
  const canvas = document.getElementById('curves-canvas');
  const W = canvas.parentElement.offsetWidth || 600;
  canvas.width = W; canvas.height = 260;
  const ctx = canvas.getContext('2d');
  const H = 260;
  const pad = {l:40,r:20,t:20,b:30};
  const cW = W-pad.l-pad.r, cH = H-pad.t-pad.b;

  ctx.fillStyle = '#09090f'; ctx.fillRect(0,0,W,H);

  for (let h = 0; h <= 24; h += 6) {
    const x = pad.l + h/24*cW;
    ctx.beginPath(); ctx.moveTo(x,pad.t); ctx.lineTo(x,pad.t+cH);
    ctx.strokeStyle = 'rgba(200,168,75,0.12)'; ctx.lineWidth = 1; ctx.stroke();
    ctx.fillStyle = 'rgba(200,168,75,0.5)';
    ctx.font = "9px 'Space Mono'"; ctx.textAlign = 'center';
    ctx.fillText(h.toString().padStart(2,'0')+'h', x, H-8);
  }

  const zeroY = pad.t + cH/2;
  ctx.beginPath(); ctx.moveTo(pad.l, zeroY); ctx.lineTo(pad.l+cW, zeroY);
  ctx.strokeStyle = 'rgba(200,168,75,0.2)'; ctx.lineWidth = 1; ctx.stroke();

  const toX = t => pad.l + (t/TAU)*cW;
  const toY = v => pad.t + (1-(v+1)/2)*cH;

  MODEL_TIMES.forEach(t => {
    const x = toX((t + chronoOffset) % TAU);
    ctx.beginPath(); ctx.moveTo(x,pad.t); ctx.lineTo(x,pad.t+cH);
    ctx.strokeStyle = 'rgba(200,168,75,0.35)'; ctx.lineWidth = 1;
    ctx.setLineDash([3,4]); ctx.stroke(); ctx.setLineDash([]);
  });

  [
    {data:SERIES.c, color:'#f0922a', alpha:0.7, width:1.2},
    {data:SERIES.temp, color:'#4ecdc4', alpha:0.7, width:1.2},
    {data:SERIES.mel, color:'#9b7fe8', alpha:0.7, width:1.2},
    {data:SERIES.comp, color:'#e8cc7a', alpha:1.0, width:2.5},
  ].forEach(({data,color,alpha,width}) => {
    ctx.beginPath();
    data.forEach((v,i) => {
      const x = toX(SERIES.t[i]), y = toY(v);
      i===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
    });
    ctx.strokeStyle = color; ctx.globalAlpha = alpha;
    ctx.lineWidth = width; ctx.stroke(); ctx.globalAlpha = 1;
  });
}

// ════════════════════════════════════════════════════════════════════════
// MONTE CARLO — CORRECTED
// ════════════════════════════════════════════════════════════════════════

let mcResults = null;

function runAndDrawMC() {
  setTimeout(() => {
    mcResults = runMonteCarlo(MODEL_ANGLES, ARTWORK, 200000);
    const ci = bootstrapCI(MODEL_ANGLES, ARTWORK, 10000);

    const pStr = mcResults.pVal < 0.00005 ? 'p<0.0001' : `p=${mcResults.pVal.toFixed(4)}`;
    document.getElementById('mc-status').textContent = pStr;

    const pPct = mcResults.pVal < 0.00005
      ? '<0.01%'
      : `${(mcResults.pVal * 100).toFixed(2)}%`;
    document.getElementById('mc-pct').textContent = `in the bottom ${pPct}`;
    document.getElementById('mc-ci').textContent =
      ` | Bootstrap 95% CI: [${ci.lo.toFixed(1)}°, ${ci.hi.toFixed(1)}°]`;
    document.getElementById('stat-p').textContent = pStr;

    drawMCHistogram();
  }, 100);
}

function drawMCHistogram() {
  if (!mcResults) return;
  const canvas = document.getElementById('mc-canvas');
  const W = canvas.parentElement.offsetWidth || 500;
  canvas.width = W; canvas.height = 220;
  const ctx = canvas.getContext('2d');
  const H = 220;
  const pad = {l:50,r:20,t:20,b:35};
  const cW = W-pad.l-pad.r, cH = H-pad.t-pad.b;

  ctx.fillStyle = '#09090f'; ctx.fillRect(0,0,W,H);

  const {maes, observedMAE, nSim} = mcResults;
  const maxMAE = Math.min(80, arrMax(maes));
  const bins = 80;
  const binSize = maxMAE / bins;
  const counts = Array(bins).fill(0);
  maes.forEach(m => { const b = Math.min(Math.floor(m/binSize), bins-1); counts[b]++; });
  const maxCount = Math.max(...counts);

  const toX = m => pad.l + (m/maxMAE)*cW;
  const toY = c => pad.t + cH - (c/maxCount)*cH;

  for (let m = 0; m <= maxMAE; m += 20) {
    const x = toX(m);
    ctx.beginPath(); ctx.moveTo(x,pad.t); ctx.lineTo(x,pad.t+cH);
    ctx.strokeStyle = 'rgba(200,168,75,0.1)'; ctx.lineWidth = 1; ctx.stroke();
    ctx.fillStyle = 'rgba(200,168,75,0.5)';
    ctx.font = "9px 'Space Mono'"; ctx.textAlign = 'center';
    ctx.fillText(m+'°', x, H-8);
  }

  ctx.fillStyle = 'rgba(200,168,75,0.5)';
  ctx.font = "9px 'Space Mono'"; ctx.textAlign = 'center';
  ctx.fillText('Mean Abs. Error (°)', pad.l+cW/2, H-20);

  counts.forEach((c, i) => {
    const x = toX(i*binSize);
    const w = Math.max(1, (cW/bins)-0.5);
    const y = toY(c);
    const mae = i*binSize;
    ctx.fillStyle = mae < observedMAE+binSize ? 'rgba(200,168,75,0.12)' : 'rgba(78,205,196,0.4)';
    ctx.fillRect(x, y, w, pad.t+cH-y);
  });

  const obsX = toX(observedMAE);
  ctx.beginPath(); ctx.moveTo(obsX,pad.t); ctx.lineTo(obsX,pad.t+cH);
  ctx.strokeStyle = '#e05a7a'; ctx.lineWidth = 2;
  ctx.setLineDash([4,3]); ctx.stroke(); ctx.setLineDash([]);

  ctx.fillStyle = '#e05a7a';
  ctx.font = "bold 10px 'Space Mono'"; ctx.textAlign = 'left';
  ctx.fillText(`Model MAE=${observedMAE.toFixed(1)}°`, obsX+4, pad.t+16);

  ctx.fillStyle = 'rgba(200,168,75,0.5)';
  ctx.font = "9px 'Space Mono'"; ctx.textAlign = 'left';
  ctx.fillText(`${(nSim/1000).toFixed(0)}k random 9-point sets`, pad.l, pad.t-6);
}

// ════════════════════════════════════════════════════════════════════════
// COMPARE CHART
// ════════════════════════════════════════════════════════════════════════

function drawCompare() {
  const canvas = document.getElementById('compare-canvas');
  const W = canvas.parentElement.offsetWidth || 500;
  canvas.width = W; canvas.height = 220;
  const ctx = canvas.getContext('2d');
  const H = 220;
  const pad = {l:50,r:20,t:30,b:40};
  const cW = W-pad.l-pad.r, cH = H-pad.t-pad.b;

  ctx.fillStyle = '#09090f'; ctx.fillRect(0,0,W,H);

  [0,90,180,270,360].forEach(deg => {
    const x = pad.l + (deg/360)*cW;
    ctx.beginPath(); ctx.moveTo(x,pad.t); ctx.lineTo(x,pad.t+cH);
    ctx.strokeStyle = 'rgba(200,168,75,0.1)'; ctx.lineWidth = 1; ctx.stroke();
    ctx.fillStyle = 'rgba(200,168,75,0.5)';
    ctx.font = "9px 'Space Mono'"; ctx.textAlign = 'center';
    ctx.fillText(deg+'°', x, H-6);
  });

  const phaseY = row => pad.t + (row/2)*cH;
  const series = [
    {label:'Ideal (40° equal)', angles:IDEAL, color:'rgba(255,255,255,0.25)', y:phaseY(0.15)},
    {label:'Model (published data)', angles:MODEL_ANGLES, color:'#4ecdc4', y:phaseY(0.5)},
    {label:'Artwork (measured)', angles:ARTWORK, color:'#c8a84b', y:phaseY(0.85)},
  ];

  series.forEach(({label,angles,color,y}) => {
    ctx.fillStyle = color;
    ctx.font = "9px 'Space Mono'"; ctx.textAlign = 'right';
    ctx.fillText(label, pad.l-4, y+3);
    angles.forEach((deg,i) => {
      const x = pad.l + (deg/360)*cW;
      ctx.beginPath(); ctx.arc(x,y,5,0,Math.PI*2);
      ctx.fillStyle = color; ctx.fill();
      ctx.fillStyle = '#09090f';
      ctx.font = "bold 7px 'Space Mono'"; ctx.textAlign = 'center';
      ctx.fillText(i+1, x, y+2.5);
    });
  });

  MODEL_ANGLES.forEach((mDeg,i) => {
    const aDeg = ARTWORK[i];
    const mx = pad.l + (mDeg/360)*cW, ax = pad.l + (aDeg/360)*cW;
    const diff = Math.abs(mDeg-aDeg);
    ctx.beginPath(); ctx.moveTo(mx, series[1].y); ctx.lineTo(ax, series[2].y);
    ctx.strokeStyle = diff<=3 ? 'rgba(107,203,168,0.3)' : 'rgba(224,90,122,0.3)';
    ctx.lineWidth = 1; ctx.stroke();
  });

  const maeM = computeMAE(ARTWORK, MODEL_ANGLES).toFixed(1);
  const maeI = computeMAE(ARTWORK, IDEAL).toFixed(1);
  ctx.fillStyle = '#4ecdc4'; ctx.font = "bold 10px 'Space Mono'"; ctx.textAlign = 'center';
  ctx.fillText(`Model MAE: ${maeM}°`, pad.l+cW*0.35, H-12);
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.fillText(`Ideal MAE: ${maeI}°`, pad.l+cW*0.72, H-12);

  document.getElementById('stat-mae').textContent = maeM + '°';
  const matches = MODEL_ANGLES.filter((m,i) => Math.abs(m-ARTWORK[i]) <= 5).length;
  document.getElementById('stat-match').textContent = matches + '/9';
}

// ════════════════════════════════════════════════════════════════════════
// VALIDATION SCATTER
// ════════════════════════════════════════════════════════════════════════

function drawValidation() {
  const canvas = document.getElementById('validation-canvas');
  const W = canvas.parentElement.offsetWidth || 500;
  canvas.width = W; canvas.height = 340;
  const ctx = canvas.getContext('2d');
  const H = 340;
  const pad = {l:60,r:20,t:30,b:40};
  const cW = W-pad.l-pad.r, cH = H-pad.t-pad.b;

  ctx.fillStyle = '#09090f'; ctx.fillRect(0,0,W,H);

  ctx.beginPath(); ctx.moveTo(pad.l,pad.t+cH); ctx.lineTo(pad.l+cW,pad.t);
  ctx.strokeStyle = 'rgba(200,168,75,0.2)'; ctx.lineWidth = 1;
  ctx.setLineDash([4,4]); ctx.stroke(); ctx.setLineDash([]);

  ctx.strokeStyle = 'rgba(200,168,75,0.3)'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(pad.l,pad.t); ctx.lineTo(pad.l,pad.t+cH); ctx.lineTo(pad.l+cW,pad.t+cH); ctx.stroke();

  [0,90,180,270,360].forEach(d => {
    const x = pad.l+(d/360)*cW, y = pad.t+cH-(d/360)*cH;
    ctx.fillStyle = 'rgba(200,168,75,0.4)';
    ctx.font = "9px 'Space Mono'"; ctx.textAlign = 'center';
    ctx.fillText(d+'°', x, pad.t+cH+14);
    ctx.textAlign = 'right'; ctx.fillText(d+'°', pad.l-6, y+3);
  });

  ctx.fillStyle = 'rgba(200,168,75,0.5)'; ctx.font = "9px 'Space Mono'"; ctx.textAlign = 'center';
  ctx.fillText('Model Predicted Angle', pad.l+cW/2, H-8);
  ctx.save(); ctx.translate(14,pad.t+cH/2); ctx.rotate(-Math.PI/2);
  ctx.fillText('Artwork Measured Angle', 0, 0); ctx.restore();

  MODEL_ANGLES.forEach((mDeg,i) => {
    const aDeg = ARTWORK[i];
    const x = pad.l+(mDeg/360)*cW, y = pad.t+cH-(aDeg/360)*cH;
    const diff = Math.abs(mDeg-aDeg);

    const yErr = (1.5/360)*cH;
    ctx.beginPath(); ctx.moveTo(x,y-yErr); ctx.lineTo(x,y+yErr);
    ctx.strokeStyle = PHASE_COLORS[i]+'88'; ctx.lineWidth = 1.5; ctx.stroke();

    ctx.beginPath(); ctx.arc(x,y,7,0,Math.PI*2);
    ctx.fillStyle = PHASE_COLORS[i]; ctx.fill();
    ctx.strokeStyle = '#09090f'; ctx.lineWidth = 1.5; ctx.stroke();

    ctx.fillStyle = '#09090f'; ctx.font = "bold 8px 'Space Mono'"; ctx.textAlign = 'center';
    ctx.fillText(i+1, x, y+2.5);

    if (diff > 3) {
      ctx.fillStyle = 'rgba(200,168,75,0.6)'; ctx.font = "8px 'Space Mono'";
      ctx.fillText(`Δ${diff.toFixed(1)}°`, x+10, y-8);
    }
  });

  const aMean = ARTWORK.reduce((a,b)=>a+b,0)/9;
  const ssRes = MODEL_ANGLES.reduce((s,m,i) => s+Math.pow(ARTWORK[i]-m,2), 0);
  const ssTot = ARTWORK.reduce((s,a) => s+Math.pow(a-aMean,2), 0);
  const r2 = (1-ssRes/ssTot).toFixed(4);

  ctx.fillStyle = '#4ecdc4'; ctx.font = "bold 11px 'Space Mono'"; ctx.textAlign = 'left';
  ctx.fillText(`R² = ${r2}`, pad.l+8, pad.t+16);
  ctx.fillStyle = 'rgba(200,168,75,0.7)'; ctx.font = "10px 'Space Mono'";
  ctx.fillText(`MAE = ${MAE_MODEL.toFixed(1)}°`, pad.l+8, pad.t+30);
}

// ════════════════════════════════════════════════════════════════════════
// SENSITIVITY CHARTS
// ════════════════════════════════════════════════════════════════════════

let sensWeightResults = null;
let sensHarmonicResults = null;

function drawSensitivity() {
  if (!sensWeightResults) {
    sensWeightResults = runWeightSensitivity(1000);
    sensHarmonicResults = runHarmonicSensitivity();
  }

  // Weight scatter
  const canvas = document.getElementById('sensitivity-canvas');
  const W = canvas.parentElement.offsetWidth || 500;
  canvas.width = W; canvas.height = 250;
  const ctx = canvas.getContext('2d');
  const H = 250;
  const pad = {l:50,r:20,t:20,b:40};
  const cW = W-pad.l-pad.r, cH = H-pad.t-pad.b;

  ctx.fillStyle = '#09090f'; ctx.fillRect(0,0,W,H);

  const maes = sensWeightResults.map(r=>r.mae);
  const minMAE = Math.min(...maes), maxMAE = Math.max(...maes);

  // axes
  ctx.strokeStyle = 'rgba(200,168,75,0.3)'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(pad.l,pad.t); ctx.lineTo(pad.l,pad.t+cH); ctx.lineTo(pad.l+cW,pad.t+cH); ctx.stroke();

  // x = cortisol weight, y = MAE
  const xMin = 0.1, xMax = 0.7, yMin = Math.floor(minMAE), yMax = Math.ceil(maxMAE)+2;

  const toX = w => pad.l + ((w-xMin)/(xMax-xMin))*cW;
  const toY = m => pad.t + cH - ((m-yMin)/(yMax-yMin))*cH;

  // Grid
  [0.2,0.3,0.4,0.5,0.6].forEach(w => {
    const x = toX(w);
    ctx.beginPath(); ctx.moveTo(x,pad.t); ctx.lineTo(x,pad.t+cH);
    ctx.strokeStyle = 'rgba(200,168,75,0.08)'; ctx.lineWidth = 1; ctx.stroke();
    ctx.fillStyle = 'rgba(200,168,75,0.4)'; ctx.font = "9px 'Space Mono'"; ctx.textAlign = 'center';
    ctx.fillText(w.toFixed(1), x, H-8);
  });
  for (let m = yMin; m <= yMax; m += 5) {
    const y = toY(m);
    ctx.beginPath(); ctx.moveTo(pad.l,y); ctx.lineTo(pad.l+cW,y);
    ctx.strokeStyle = 'rgba(200,168,75,0.06)'; ctx.lineWidth = 1; ctx.stroke();
    ctx.fillStyle = 'rgba(200,168,75,0.4)'; ctx.font = "9px 'Space Mono'"; ctx.textAlign = 'right';
    ctx.fillText(m+'°', pad.l-4, y+3);
  }

  ctx.fillStyle = 'rgba(200,168,75,0.5)'; ctx.font = "9px 'Space Mono'"; ctx.textAlign = 'center';
  ctx.fillText('Cortisol Weight (w₁)', pad.l+cW/2, H-22);

  // Points
  sensWeightResults.forEach(r => {
    const x = toX(r.w1), y = toY(r.mae);
    ctx.beginPath(); ctx.arc(x,y,2.5,0,Math.PI*2);
    ctx.fillStyle = 'rgba(78,205,196,0.35)'; ctx.fill();
  });

  // Default weight marker
  const defX = toX(0.5), defY = toY(MAE_MODEL);
  ctx.beginPath(); ctx.arc(defX,defY,6,0,Math.PI*2);
  ctx.fillStyle = '#e05a7a'; ctx.fill();
  ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1.5; ctx.stroke();
  ctx.fillStyle = '#ffffff'; ctx.font = "bold 9px 'Space Mono'"; ctx.textAlign = 'left';
  ctx.fillText('Default weights', defX+10, defY+3);

  // Stats text
  const meanMAE = (maes.reduce((a,b)=>a+b,0)/maes.length).toFixed(1);
  const stdMAE = Math.sqrt(maes.reduce((s,m)=>s+Math.pow(m-meanMAE,2),0)/maes.length).toFixed(1);
  document.getElementById('sensitivity-stats').innerHTML =
    `<strong style="color:var(--text)">Weight sensitivity:</strong> Across 1,000 random weight vectors, ` +
    `MAE ranges from <span style="color:var(--mint);font-family:var(--font-mono)">${minMAE.toFixed(1)}°</span> to ` +
    `<span style="color:var(--rose);font-family:var(--font-mono)">${maxMAE.toFixed(1)}°</span> ` +
    `(mean ${meanMAE}° ± ${stdMAE}°). The default weights produce MAE = ${MAE_MODEL.toFixed(1)}°. ` +
    `<strong style="color:var(--mint)">Conclusion: the 9-phase structure is robust to weight choice.</strong>`;

  // Harmonic sensitivity bars
  const container = document.getElementById('harmonic-sensitivity');
  container.innerHTML = '';
  const markers = ['cortisol','coreTemp','melatonin'];
  const markerLabels = {cortisol:'Cortisol', coreTemp:'Core Temp.', melatonin:'Melatonin'};

  markers.forEach(marker => {
    const items = sensHarmonicResults.filter(r=>r.marker===marker);
    if (items.length === 0) return;
    const baseMAE = items.find(r=>r.perturbation===0);
    const baseVal = baseMAE ? baseMAE.mae : MAE_MODEL;
    const maxPertMAE = Math.max(...items.map(r=>r.mae));
    const maxRange = 30;

    items.forEach(item => {
      const bar = document.createElement('div');
      bar.className = 'sensitivity-bar';
      const pStr = item.perturbation > 0 ? `+${(item.perturbation*100).toFixed(0)}%` : `${(item.perturbation*100).toFixed(0)}%`;
      bar.innerHTML = `
        <div class="sens-label">${markerLabels[marker]} ${pStr}</div>
        <div class="sens-track">
          <div class="sens-fill" style="width:${Math.min(100,(item.mae/maxRange)*100)}%;background:${item.mae <= baseVal+1 ? 'var(--mint)' : item.mae <= baseVal+3 ? 'var(--gold)' : 'var(--rose)'}80;"></div>
        </div>
        <div class="sens-val">${item.mae.toFixed(1)}°</div>
      `;
      container.appendChild(bar);
    });
  });
}

// ════════════════════════════════════════════════════════════════════════
// PHASE TABLE
// ════════════════════════════════════════════════════════════════════════

function buildPhaseTable() {
  const container = document.getElementById('phase-table');
  container.innerHTML = '';
  MODEL_TIMES.forEach((t, i) => {
    const row = document.createElement('div');
    row.className = 'phase-row';
    row.id = `pr-${i}`;
    const fmt = h => {
      h = (h + chronoOffset) % TAU;
      const hh = Math.floor(h) % 24;
      const mm = Math.round((h - Math.floor(h)) * 60) % 60;
      return hh.toString().padStart(2,'0') + ':' + mm.toString().padStart(2,'0');
    };
    row.innerHTML = `
      <div class="pr-col pr-num">${i+1}</div>
      <div class="pr-col pr-swatch" style="background:${PHASE_COLORS[i]};padding:0;"></div>
      <div class="pr-col pr-name" style="color:${PHASE_COLORS[i]}">${PHASE_DATA[i].name}</div>
      <div class="pr-col pr-time">${fmt(t)}</div>
      <div class="pr-col pr-bio">${PHASE_DATA[i].bio}</div>
    `;
    container.appendChild(row);
  });
}

// ════════════════════════════════════════════════════════════════════════
// TAB SWITCHING
// ════════════════════════════════════════════════════════════════════════

function showPane(name, btn) {
  document.querySelectorAll('.pane').forEach(p => p.classList.remove('visible'));
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  document.getElementById('pane-' + name).classList.add('visible');
  btn.classList.add('active');

  if (name === 'curves') setTimeout(drawCurves, 50);
  if (name === 'validation') setTimeout(drawValidation, 50);
  if (name === 'sensitivity') setTimeout(drawSensitivity, 50);
}

function updateLiveTime() {
  const now = new Date();
  document.getElementById('live-time').textContent =
    now.toLocaleTimeString('en-US', {hour12:false, hour:'2-digit', minute:'2-digit', second:'2-digit'});
}

document.getElementById('chrono-slider').addEventListener('input', function() {
  const val = parseInt(this.value);
  chronoOffset = val / 10;
  const label = chronoOffset < 0.8 ? 'Morning' : chronoOffset < 2.2 ? 'Intermediate' : 'Evening';
  document.getElementById('chrono-val').textContent = `+${chronoOffset.toFixed(1)} h (${label})`;
  buildPhaseTable();
  drawCurves();
});

let resizeTimer;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(() => {
    drawCurves();
    if (mcResults) drawMCHistogram();
    drawCompare();
    drawValidation();
  }, 200);
});

function init() {
  buildPhaseTable();
  drawCurves();
  drawClock();
  updateLiveTime();
  setInterval(() => { drawClock(); updateLiveTime(); }, 1000);
  runAndDrawMC();
  setTimeout(() => { drawCompare(); drawValidation(); }, 300);
}

window.addEventListener('load', init);
</script>
</body>
</html>
